import{DrawingInteraction}from"./DrawingInteraction.js";import{Master}from"./Master.js";import{Slave}from"./Slave.js";import{TopologyView}from"./Topology.js";import{LayerName}from"./Layer.js";import{store}from"./Appearance.js";import{PortName,PortStates}from"./Port.js";import{ExtendedInfoOfMaster,ExtendedInfoOfSlave}from"./ExtendedInfo.js";import{customElementsPrefix}from"./Defines.js";export const DrawingSlaveSettings={scale:.6,padding:{x:100,y:70}};export class DrawingSlave extends DrawingInteraction{constructor(slave){if(!slave)throw new Error("Required parameter `slave` is missing or undefined. The constructor is probably called by document.createElement() or the html tag and therefore no parameters were passed.");const drawingDimension={width:(2*DrawingSlaveSettings.padding.x+slave.design.dimension.width)*DrawingSlaveSettings.scale,height:(2*DrawingSlaveSettings.padding.y+slave.design.dimension.height)*DrawingSlaveSettings.scale};super(slave.master.main,slave.master,TopologyView.Slave,drawingDimension),this.__zoomLevel=DrawingSlaveSettings.scale,this.__slave=slave}__initSetTimeout=0;connectedCallback(){this.initDrawing(),this.__initSetTimeout=setTimeout(()=>{const drawingDimension={width:2*DrawingSlaveSettings.padding.x+this.__slave.design.dimension.width,height:2*DrawingSlaveSettings.padding.y+this.__slave.design.dimension.height};this.setInitialDimension(drawingDimension),this.drawSlave()},0)}disconnectedCallback(){this.__tooltip.remove(),clearTimeout(this.__initSetTimeout),this.__initSetTimeout=0}__slave;setInitialDimension(dimension){super.setInitialDimension(dimension)}drawSlave(){const layers=this.__focusedLayers;this.__translateOrigin(layers,DrawingSlaveSettings.padding),super.drawSlave(this.__slave,layers),this.__drawPortLabels(),this.__revertOriginTranslation(layers)}update(){super.update(),this.drawSlave(),this.updateHover()}__drawPortLabels(){if(!store.appearance)return void TcHmi.Log.error("Appearance is null.");const master=this.__master;if(!master)return;const ctx=this.__focusedLayers.getContext(LayerName.processData),ports=this.__slave.ports,slaveWidth=this.__slave.design.dimension.width;for(const port of ports)if(port.exists){const labelSize=50;let crcLabelColor=store.appearance.port.label.warning.bgColor;const crc=port.online.counter.crc,portPosAbs={x:port.pos.rel.x,y:port.pos.rel.y};let labelPosAbs={x:0,y:0};labelPosAbs=port.index===PortName.A?{x:-50,y:portPosAbs.y}:{x:slaveWidth+50,y:portPosAbs.y};let labelColor=store.appearance.msgLevel.disabled;port.configured&&port.state!==PortStates.notPresent&&(labelColor=store.appearance.port.label.success.bgColor),crc.total.value&&(ctx.beginPath(),crcLabelColor=store.appearance.port.label.error.bgColor,labelColor=store.appearance.port.label.error.bgColor,crc.errorOnPrevPort.value&&(crcLabelColor=store.appearance.port.label.warning.bgColor,labelColor=store.appearance.port.label.warning.bgColor)),port.state===PortStates.error&&(labelColor=store.appearance.port.label.error.bgColor),ctx.strokeStyle=ctx.fillStyle=labelColor.getRGBAString();let clkFn,strokeOffset=labelSize/2;port.index===PortName.A&&(strokeOffset=-strokeOffset),ctx.lineWidth=2,ctx.moveTo(portPosAbs.x,portPosAbs.y),ctx.lineTo(labelPosAbs.x-strokeOffset,labelPosAbs.y),ctx.stroke(),ctx.beginPath(),ctx.fillRect(labelPosAbs.x-labelSize/2,labelPosAbs.y-labelSize/2,labelSize,labelSize);let hoverText=`{{Port_Name$${PortName[port.index]}}}`,configuredComponent=port.configuredComponent;if(port.redundancy&&(configuredComponent=master,hoverText+=" ({{Redundancy}})"),configuredComponent){if(configuredComponent instanceof Master){const configuredMaster=configuredComponent;hoverText+=`<br /> <br />{{Tooltip_Port_Label_Pointer_Primary_Interaction_To_Connected_Master$${configuredMaster.name}}}`,clkFn=()=>{master.setExtendedInfoOfMaster(new ExtendedInfoOfMaster(configuredMaster))}}else if(configuredComponent instanceof Slave){const configuredSlave=configuredComponent;hoverText+=`<br /><br />{{Tooltip_Port_Label_Pointer_Primary_Interaction_To_Connected_Slave$${configuredSlave.name}}}`,clkFn=()=>{master.setExtendedInfoOfSlave(new ExtendedInfoOfSlave(configuredSlave))}}}else hoverText+=" ({{Port_Not_Connected}})";this.__addEventTarget({relativePos:{x:labelPosAbs.x-labelSize/2,y:labelPosAbs.y-labelSize/2},dimension:{width:labelSize,height:labelSize},hoverText,primaryPointerFn:clkFn});const labelLeftBottomPos={x:labelPosAbs.x-labelSize/2,y:labelPosAbs.y+labelSize/2-10};if(crc.total.value&&(ctx.fillStyle=crcLabelColor.getRGBAString(),ctx.fillRect(labelLeftBottomPos.x,labelLeftBottomPos.y,labelSize,25)),ctx.fillStyle="white",ctx.textAlign="center",ctx.textBaseline="middle",ctx.font=`20px ${store.appearance.fontFamily}`,ctx.fillText(PortName[port.index],labelPosAbs.x,labelPosAbs.y),crc.total.value){const subLabelCenterPos={x:labelPosAbs.x,y:labelLeftBottomPos.y+12};ctx.fillStyle="white",ctx.textAlign="center",ctx.textBaseline="middle";let fontSize=16,textFitIn=!1;for(;!textFitIn;)ctx.font=`${fontSize}px ${store.appearance.fontFamily}`,textFitIn=ctx.measureText(crc.total.value.toString()).width<labelSize-5,fontSize-=2;ctx.fillText(crc.total.value.toString(),subLabelCenterPos.x,subLabelCenterPos.y)}}}}customElements.define(customElementsPrefix+"drawing-slave",DrawingSlave);